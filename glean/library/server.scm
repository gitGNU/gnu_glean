;;; glean --- fast learning tool.         -*- coding: utf-8 -*-

;;;; Module Server

;; Copyright (C) 2008, 2010, 2012 Alex Sassmannshausen

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3 of
;; the License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; if not, contact:
;;
;; Free Software Foundation           Voice:  +1-617-542-5942
;; 59 Temple Place - Suite 330        Fax:    +1-617-542-2652
;; Boston, MA  02111-1307,  USA       gnu@gnu.org

;;; Commentary:
;;;
;;; The Module Server manages known glean modules and
;;; module-hash-maps. It also provide challenge access and evaluation
;;; functionality.
;;;
;;; It uses the server communication framework defined in base-server,
;;; implements a module server specific dispatcher, and the logic for
;;; carrying out the functionality implied through the requests it
;;; receives.

;;;; Documentation:
;;; 
;;; The Module Server works as follows:
;;;
;;; Hashmaps Introduced:
;;; 
;;; The profile server does not know anything about modules: it
;;; retains an abstract idea the progress of a player by associating
;;; progress with a form of UUID. This UUID is known as a sethash. The
;;; profile server is capable of mapping a given sethash to a specific
;;; set. It is also capable of generating a sethash for any given
;;; set. 
;;; 
;;; Sethashes:
;;; 
;;; Sethashes need to be sufficiently long to avoid hash collisions
;;; between sets that may have the same id. This allows the profile
;;; server to store progress in sets in a flat list. There are 2
;;; special types of sethashes: roothashes (root-sethashes) and
;;; crownhashes (crown-sethashes). The former designate a sethash
;;; referring to a set at the bottom of a set-hierarchy (i.e. it's a
;;; set containing only problems rather than further sets). Roothashes
;;; will be converted in the profile server to root-blobhashes: a
;;; blobhash with no entries in its 'children' field (blobhashes
;;; contain a player's progress for a given set). Conversely, a
;;; crownhash will be converted to a crown-blobhash, a blobhash
;;; containing no entries in its 'parents' field. The module server
;;; has no concept of hashes as deep as a blobhash: sethashes are
;;; plain strings. As a result sethashes do not tell its user whether
;;; they are a roothash or crownhash.
;;;
;;; Hashpaths:
;;;
;;; It is necessary for the profile server to know whether a sethash,
;;; out of which it will construct a blobhash, is a roothash, a
;;; crownhash or an ordinary sethash. More than that, the profile
;;; server must know the position of a given sethash in a module's set
;;; hierarchy. Without this information it would be unable to properly
;;; populate the parents and children fields of the resulting
;;; blobhashes. Without the latter in turn it could not effectively
;;; treat a fundamentally hierarchical data set like glean
;;; modules as a flat list. To this end the module servers provide the
;;; initial information about a given module's sethashes in the form
;;; of a hashpath.  A hashpath is a hierarchy of nested pairs, or a
;;; tree. The car of each hashpath is the sethash for a module's
;;; crownset. The cdr contains a list of its child nodes. Each child
;;; node in turn is a pair consisting of a (car) sethash and (cdr)
;;; list of child nodes.
;;; 
;;; Hashmaps Revisited:
;;;
;;; Finally, a hashmap is a list containing one or more hashpaths. It
;;; is generated by the module server in response to a hashmap
;;; request, which provides a list of module IDs. The module server
;;; converts these IDs into a hashmap, one hashpath per module ID.

;;; Code:

(define-module (glean library server)
  #:use-module (glean config)
  #:use-module (glean common base32)
  #:use-module (glean common base-server)
  #:use-module (glean common base-requests)
  #:use-module (glean common comtools)
  #:use-module (glean common module-requests)
  #:use-module (glean common profile-requests)
  #:use-module (glean common utils)
  #:use-module (glean library sets)
  #:use-module (glean library library-store)
  #:use-module (glean lounge scorecards) ; Should be obsolete?
  #:use-module (glean lounge gprofiles)  ; Should be obsolete?
  #:use-module (ice-9 rdelim)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-26)
  #:use-module (rnrs)
  #:export (library-server))

;;;;; Module Server Dispatch Logic
;;;; Define the actual module server and the server-dispatcher used
;;;; by it.
(define (library-server module-socket-file)
  (the-server module-socket-file server-dispatcher))

(define (server-dispatcher request)
  "Interprets client requests, and passes additional information for
handling to request handler."

  (cond ((eof-object? request)
         #f)

        ((request? request)
         (let ((rq (rq-content request)))
           (guard (err
                   (err
                    (begin
                      (clog err)
                      (format #t
                              "Error in dispatcher: ~a.\n"
                              err)
                      (negs rq err))))
                  (cond ((aliveq? rq)
                         (acks rq))
                        ((challq? rq)
                         (challenge-provider rq))
                        ((evalq? rq)
                         (eval-provider rq))
                        ((knownq? rq)
                         (known-mods-provider rq))
                        ((detailq? rq)
                         (details-provider rq))
                        ((sethashesq? rq)
                         (sethashes-provider rq))
                        ((hashmapq? rq)
                         (hashmap-provider rq))
                        ((quitq? rq)
                         (acks rq))
                        (else (unks rq))))))

        (else (unks request))))
;;;;; Server Response Creation
;;;; Functions that provide request specific parsing and response
;;;; skeletons.
(define (challenge-provider rq)
  (define (new-challenge problem)
    "Return the challenge located in the set identified by BLOBHASH and
COUNTER, or raise 'invalid-set."
    ;; FIXME: this procedure is logic, not parsing, so it should be in
    ;; library-store, not in module-server.
    (let ((s  (problem-s problem))
          (q  (problem-q problem))
          (os (problem-o problem)))
      (list (cons (q-text q) (q-media q))
            (if (null? os)
                '()
                (map (lambda (o) (cons (o-text o) (o-media o))) os))
            ;; FIXME: solution for allowing different question types.
            (cond ((not s)          'info)
                  ((and (list? s) (> (length s) 1)) 'multi)
                  ((null? os)       'open)
                  (else             'single)))))

  (let ((bh (challq-hash rq))
        (c (challq-counter rq)))
    (cond ((not (blobhash? bh))
           (raise 'invalid-blobhash))
          ((not (number? c))
           (raise 'invalid-counter))
          (else (challs (new-challenge (fetch-problem bh c)))))))

(define (fetch-problem blobhash counter)
  (let ((set (fetch-set blobhash (store-hash %library-dir%))))
    (if set
        (let* ((problems (set-contents set))
               (num-of-problems (length problems)))
          (list-ref problems (modulo counter num-of-problems)))
        (raise 'unknown-set))))

(define (eval-provider rq)
  (define (eval-answer problem answer)
    "Return the evaluation result of ANSWER with respect to PROBLEM."
    ;; FIXME: quick hack to allow for multiple solutions, or none.
    (let ((solution (problem-s problem)))
      (cond ((not solution) #t)
            ((list? solution)
             (let ((sol (map s-text solution)))
               (fold (lambda (solution answer result)
                       (if result
                           (equal? solution result)
                           #f))
                     #t sol answer)))
            (else
             (equal? (s-text solution) answer)))))
  (define (fetch-solution problem)
    (if (not (problem-s problem))
        "irrelevant"
        (problem-s problem)))

  (let ((bh (evalq-hash rq))
        (c (evalq-counter rq))
        (answer (evalq-answer rq)))
    (cond ((not (blobhash? bh))
           (raise 'invalid-blobhash))
          ((not (number? c))
           (raise 'invalid-counter))
          ((not (or (string? answer) (list? answer)))
           (raise 'invalid-answer))
          (else
           (let ((problem (fetch-problem bh c)))
             (evals (eval-answer problem answer)
                    (fetch-solution problem)))))))

(define (known-mods-provider rq)
  (define (valid-search? pair)
    "Return #t if pair is a pair and contains a valid search pattern."
    (and (pair? pair)
         (cond ((eqv? (car pair) 'hash) ; hash
                (and (list? (cdr pair))
                     (null? (filter (negate symbol?)
                                    (cdr pair)))))
               ((eqv? (car pair) 'keywords) ; keywords
                (and (list? (cdr pair))
                     (null? (filter (negate string?)
                                    (cdr pair)))))
               ((eqv? (car pair) 'name) ; name
                (and (list? (cdr pair))
                     (null? (filter (negate string?)
                                    (cdr pair)))))
               (else                    ; fail
                #f))))
  (let ((operator (knownq-operator rq))
        (search   (knownq-search   rq)))
    (cond ((and (not operator)
                (not search))           ; known-crownsets
           (knowns (known-crownsets (store-hash %library-dir%)
                                    %ignore-keywords%)))
          ;; search contains an invalid operator
          ((not (or (eqv? operator 'match))) ; operator
           (raise 'invalid-operator))
          ;; search contains only valid terms
          ((and (list? search)
                (valid-search? search)) ; search
           (knowns (search-sets operator search
                                (store-hash %library-dir%))))
          (else                         ;fail
           (raise 'invalid-search)))))

(define (details-provider rq)
  (let ((hash (detailq-hash rq)))
    (if (blobhash? hash)
        (details (set-details hash (store-hash %library-dir%)))
        (raise 'invalid-sethash))))

(define (hashmap-provider rq)
  (let ((hashpairs (hashmapq-hashpairs rq)))
    (if (and (list? hashpairs)
             (fold (lambda (hashpair previous)
                     (and previous (pair? hashpair)
                          (blobhash? (car hashpair))   ; minhash
                          (blobhash? (cdr hashpair)))) ; fullhash
                   #t hashpairs))
        (let ((sets (filter-map
                     (lambda (hashpair)
                       (fetch-set (cdr hashpair)
                                  (store-hash %library-dir%)))
                     hashpairs)))
          (if (not (null? sets))
              (hashmaps (map make-hashtree sets))
              (raise 'unknown-set-ids)))
        (raise 'invalid-set-ids))))

(define (sethashes-provider rq)
  (let ((fullhashes (sethashesq-fullhashes rq)))
    (if (and (list? fullhashes)
             (null? (filter (negate blobhash?) fullhashes)))
        (sethashess (set-hashpairs fullhashes
                                   (store-hash %library-dir%)))
        (raise 'invalid-fullhashes))))
